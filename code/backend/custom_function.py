from backend.function import Function
from backend.helper_type import Value
from backend.tree import Tree
from backend.unify import Fun


class CustomFunction(Function):
    """Implements a user-defined function

    Parameters
    ----------
    function_signature
        Type signature of function
    instructions
        Instruction tree as generated by Demonstration
    constants
        Map from names of constants to their values as generated by Demonstration
    unique_id
        Number that should be unique across all functions that exist in the system
    """
    def __init__(self, function_signature: Fun, instructions: Tree, constants: dict[str, Value], unique_id: int):
        super().__init__(function_signature, unique_id)
        self._instructions: Tree = instructions
        self._constants: dict[str, Value] = constants

    def initial_context(self, args: list[Value]) -> dict[str, Value]:
        """Generates and returns the initial context.
        This allows that all values (including inputs and constants) can be referred to by name by instructions.

        Raises
        ------
        NoneAsFunArg
            If the function receives None as an argument (i.e. None is in args)
        ValueError
            If args is empty even though the function expects at least one argument
        TypeError
            If unification fails (i.e. expected types of arguments don't match received types of arguments)
        """
        return self.input_context(args) | self._constants

    def compute(self, args: list[Value]) -> Value:
        """Computes and returns the result of the function given the arguments ``args``

        Raises
        ------
        NoneAsFunArg
            If the function receives None as an argument (i.e. None is in args)
        ValueError
            If args is empty even though the function expects at least one argument
        TypeError
            If unification fails (i.e. expected types of arguments don't match received types of arguments)
        IndexError
            If next instruction doesn't exist (e.g. missing return due to executing compute(args) before function
            synthesis has fully terminated)
        """
        context: dict[str, Value] = self.initial_context(args)
        block_counter: int = 0
        current_node: Tree = self._instructions

        while True:
            tmp_name, expr = current_node.get_instruction(block_counter)

            if expr[0] == "ret":  # Instruction: (None, ["ret" "<name>"])
                return context[expr[1]]

            elif expr[0] == "branch":  # Instruction: (None, ["branch", "<name>"])
                cnd_val = context[expr[1]]
                current_node = current_node.get_true() if cnd_val else current_node.get_false()
                block_counter = 0

            elif expr[0] == "self":  # Instruction: ("<temp_name>", ["self", "<arg0>", "<arg1>", ...])
                f_args = [context[arg] for arg in expr[1:]]
                context[tmp_name] = self.compute(f_args)

                block_counter += 1

            elif expr[0] in context:  # Instruction: ("<temp_name>", ["<f_name>", "<arg0>", "<arg1>", ...])
                f = context[expr[0]]
                f_args = [context[arg] for arg in expr[1:]]

                context[tmp_name] = f.compute(f_args)

                block_counter += 1

            else:
                assert False, f"Cannot evaluate {expr[0]}"
